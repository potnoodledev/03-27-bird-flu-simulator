<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>First Person Shooter</title>
    <link rel="stylesheet" href="css/examples.css?ver=1.0.0" />
    <script src="lib/phaser.min.js?ver=3.52.0"></script>
    <script src="lib/enable3d/enable3d.phaserExtension.0.25.4.min.js"></script>
  </head>

  <body>
    <div id="info-text">
      Use WASD to move, Q and E to tilt, right mouse button to aim and left mouse button to shoot. Hunt down the 50 chickens!
    </div>
    <script>
      const { enable3d, Scene3D, Canvas, ThirdDimension, ExtendedObject3D, FirstPersonControls, THREE } = ENABLE3D

      class MainScene extends Scene3D {
        constructor() {
          super({ key: 'MainScene' })
          this.move = { x: 0, y: 0, z: 0 }
          this.chickens = []
          this.chickenModel = null
          this.chickenCount = 50
        }

        postRender() {
          this.third.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight)
          this.third.renderer.render(this.third.scene, this.third.camera)

          this.third.renderer.clearDepth()

          this.third.renderer.setScissorTest(true)
          this.third.renderer.setScissor(50, 50, 150, 100)
          this.third.renderer.setViewport(50, 50, 150, 100)

          this.third.renderer.render(this.third.scene, this.secondCamera)

          this.third.renderer.setScissorTest(false)
        }

        create() {
          this.accessThirdDimension({ maxSubSteps: 10, fixedTimeStep: 1 / 180 })

          this.third.warpSpeed('-orbitControls')
          this.third.renderer.gammaFactor = 1.5
          this.third.camera.layers.enable(1) // enable layer 1

          // second camera
          this.secondCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)
          this.third.add.existing(this.secondCamera)
          this.third.camera.add(this.secondCamera)
          // this.secondCamera.layers.set(1)

          this.scene.scene.game.events.on('postrender', (renderer, time, delta) => {
            this.postRender()
          })

          this.third.load.gltf('assets/glb/chicken.glb').then(object => {
            const rifle = object.scene

            this.rifle = new ExtendedObject3D()
            this.rifle.name = 'rifle'
            this.rifle.add(rifle)

            this.third.add.existing(this.rifle)

            this.rifle.traverse(child => {
              if (child.isMesh) {
                child.layers.set(1) // mesh is in layer 1
                child.castShadow = child.receiveShadow = true
                if (child.material) child.material.metalness = 0
              }
            })
            
            // Now that the model is loaded, use it to create chickens
            this.createChickens(object)
          })

          // add red dot
          this.redDot = this.add.circle(this.cameras.main.width / 2, this.cameras.main.height / 2, 4, 0xff0000)
          this.redDot.depth = 1

          // add player
          this.player = new ExtendedObject3D()
          this.player.position.setY(2)
          
          // create an array to store bullets
          this.bullets = []

          // add first person controls
          this.firstPersonControls = new FirstPersonControls(this.third.camera, this.player, {})

          // lock the pointer and update the first person control
          this.input.on('pointerdown', () => {
            this.input.mouse.requestPointerLock()
          })
          this.input.on('pointermove', pointer => {
            if (this.input.mouse.locked) {
              this.firstPersonControls.update(pointer.movementX, pointer.movementY)
            }
          })
          this.events.on('update', () => {
            this.firstPersonControls.update(0, 0)
          })

          // add keys
          this.keys = {
            w: this.input.keyboard.addKey('w'),
            a: this.input.keyboard.addKey('a'),
            s: this.input.keyboard.addKey('s'),
            d: this.input.keyboard.addKey('d'),
            q: this.input.keyboard.addKey('q'),
            e: this.input.keyboard.addKey('e')
          }

          // Mark ground as non-destructible
          this.third.physics.add.ground({ width: 50, height: 50, name: 'ground', userData: { destructible: false } })
          
          // Add UI for remaining chickens
          this.chickensRemainingText = this.add.text(10, 10, `Chickens: ${this.chickenCount}`, { 
            fontSize: '24px', 
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 4
          })
          this.chickensRemainingText.setScrollFactor(0)
          this.chickensRemainingText.depth = 1000
        }
        
        createChickens(model) {
          // Create 50 chickens scattered around the map
          for (let i = 0; i < this.chickenCount; i++) {
            // Clone the chicken model
            const chickenScene = model.scene.clone()
            
            // Create a new ExtendedObject3D for the chicken
            const chicken = new ExtendedObject3D()
            chicken.name = `chicken_${i}`
            chicken.add(chickenScene)
            
            // Set random position within a reasonable area
            const x = (Math.random() - 0.5) * 40
            const z = (Math.random() - 0.5) * 40
            chicken.position.set(x, 10, z)
            
            // Random rotation
            chicken.rotation.y = Math.random() * Math.PI * 2
            
            // Scale down the chicken
            chicken.scale.set(0.5, 0.5, 0.5)
            
            // Set chicken properties
            chicken.userData.destructible = true
            
            // Add to scene
            this.third.add.existing(chicken)
            
            // Add physics body to chicken
            chicken.physics = this.third.physics.add.existing(chicken, {
              shape: 'box',
              width: 0.5,
              height: 1.4,
              depth: 0.5,
              mass: 1
            })
            
            // Tweak physics body
            chicken.body.setFriction(0.8)
            chicken.body.setAngularFactor(0, 1, 0) // Only allow rotation around Y axis
            
            // Store in array for easy access
            this.chickens.push(chicken)
          }
        }

        update(time, delta) {
          if (this.rifle && this.rifle) {
            // Update chicken counter
            if (this.chickensRemainingText) {
              const remainingChickens = this.chickens.filter(chicken => chicken.body && !chicken.body.isDestroyed).length
              this.chickensRemainingText.setText(`Chickens: ${remainingChickens}`)
            }
            
            // some variables
            const zoom = this.input.mousePointer.rightButtonDown()
            const speed = 0.1
            const direction = new THREE.Vector3()
            const rotation = this.third.camera.getWorldDirection(direction)
            const theta = Math.atan2(rotation.x, rotation.z)

            // reset red dot
            this.redDot.alpha = 1

            // the rifle movement
            if (zoom) {
              this.redDot.alpha = 0
              this.move.x = THREE.MathUtils.lerp(this.move.x, 0.6, 0.2)
              this.move.y = THREE.MathUtils.lerp(this.move.y, -0.8 + 1.8, 0.2)
              this.move.z = THREE.MathUtils.lerp(this.move.z, -0.45, 0.2)
            } else if (this.keys.w.isDown) {
              this.move.x = Math.sin(time * -0.015) * 0.075
              this.move.y = Math.sin(time * 0.015) * 0.075
              this.move.z = Math.sin(time * 0.015) * 0.075
            } else {
              this.move.x = Math.sin(time * -0.003) * 0.01
              this.move.y = Math.sin(time * 0.003) * 0.01
              this.move.z = Math.sin(time * 0.003) * 0.01
            }

            // tilt
            if (this.keys.q.isDown) {
              this.third.camera.rotateZ(0.2)
              this.firstPersonControls.offset = new THREE.Vector3(
                Math.sin(theta + Math.PI * 0.5) * 0.4,
                0,
                Math.cos(theta + Math.PI * 0.5) * 0.4
              )
            } else if (this.keys.e.isDown) {
              this.third.camera.rotateZ(-0.2)
              this.firstPersonControls.offset = new THREE.Vector3(
                Math.sin(theta - Math.PI * 0.5) * 0.4,
                0,
                Math.cos(theta - Math.PI * 0.5) * 0.4
              )
            } else {
              this.third.camera.rotateZ(0)
              this.firstPersonControls.offset = new THREE.Vector3(0, 0, 0)
            }

            // adjust the position of the rifle to the camera
            const raycaster = new THREE.Raycaster()
            // x and y are normalized device coordinates from -1 to +1
            raycaster.setFromCamera({ 
              x: -1 - this.move.x, 
              y: -1.5 - this.move.y,
            }, this.third.camera)
            const pos = new THREE.Vector3()
            pos.copy(raycaster.ray.direction)
            pos.multiplyScalar(1.6 + this.move.z)
            pos.add(raycaster.ray.origin)

            this.rifle.position.copy(pos)
            this.rifle.rotation.copy(this.third.camera.rotation)

            // move forwards and backwards
            if (this.keys.w.isDown) {
              this.player.position.x += Math.sin(theta) * speed
              this.player.position.z += Math.cos(theta) * speed
            } else if (this.keys.s.isDown) {
              this.player.position.x -= Math.sin(theta) * speed
              this.player.position.z -= Math.cos(theta) * speed
            }

            // move sideways
            if (this.keys.a.isDown) {
              this.player.position.x += Math.sin(theta + Math.PI * 0.5) * speed
              this.player.position.z += Math.cos(theta + Math.PI * 0.5) * speed
            } else if (this.keys.d.isDown) {
              this.player.position.x += Math.sin(theta - Math.PI * 0.5) * speed
              this.player.position.z += Math.cos(theta - Math.PI * 0.5) * speed
            }

            // shoot
            if (this.input.mousePointer.leftButtonDown()) {
              const x = 0
              const y = 0
              const force = 5
              const pos = new THREE.Vector3()

              raycaster.setFromCamera({ x, y }, this.third.camera)

              pos.copy(raycaster.ray.direction)
              pos.add(raycaster.ray.origin)

              const sphere = this.third.physics.add.sphere(
                { radius: 0.05, x: pos.x, y: pos.y, z: pos.z, mass: 5, bufferGeometry: true },
                { phong: { color: 0x33ee22 } }
              )

              pos.copy(raycaster.ray.direction)
              pos.multiplyScalar(24)

              sphere.body.applyForce(pos.x * force, pos.y * force, pos.z * force)
              
              // Track the bullet
              this.bullets.push(sphere)
              
              // Add collision detection to the bullet
              sphere.body.on.collision((otherObject, event) => {
                if (otherObject.name !== 'ground' && otherObject.name !== 'rifle') {
                  // Destroy the hit object
                  if (otherObject.userData.destructible !== false) {
                    // Check if it's a chicken
                    if (otherObject.name.includes('chicken')) {
                      // Mark as destroyed for counting purposes
                      otherObject.body.isDestroyed = true
                      
                      // Play death animation - fade out and sink into ground
                      const deathAnimation = this.tweens.add({
                        targets: [otherObject.position],
                        y: -1,
                        duration: 1000,
                        ease: 'Power2',
                        onComplete: () => {
                          // Only remove when animation is complete
                          this.third.scene.remove(otherObject)
                          this.third.physics.destroy(otherObject)
                        }
                      })
                    } else {
                      // Non-chicken objects
                      this.third.scene.remove(otherObject)
                      this.third.physics.destroy(otherObject)
                    }
                  }
                  
                  // Destroy the bullet
                  this.third.scene.remove(sphere)
                  this.third.physics.destroy(sphere)
                  
                  // Remove bullet from the array
                  const index = this.bullets.indexOf(sphere)
                  if (index > -1) {
                    this.bullets.splice(index, 1)
                  }
                }
              })
            }
            
            // Make chickens randomly move around
            if (this.chickens.length > 0 && Math.random() < 0.01) {
              // Randomly select a chicken that isn't destroyed
              const liveChickens = this.chickens.filter(chicken => chicken.body && !chicken.body.isDestroyed)
              if (liveChickens.length > 0) {
                const randomChicken = liveChickens[Math.floor(Math.random() * liveChickens.length)]
                
                // Apply random movement force
                const forceX = (Math.random() - 0.5) * 2
                const forceZ = (Math.random() - 0.5) * 2
                
                randomChicken.body.applyForce(forceX, 0, forceZ)
                
                // Also rotate to face movement direction
                if (forceX !== 0 || forceZ !== 0) {
                  const angle = Math.atan2(forceX, forceZ)
                  randomChicken.rotation.y = angle
                }
              }
            }
          }
        }
      }

      const config = {
        type: Phaser.WEBGL,
        transparent: true,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: window.innerWidth * Math.max(1, window.devicePixelRatio / 2),
          height: window.innerHeight * Math.max(1, window.devicePixelRatio / 2)
        },
        scene: [MainScene]
      }

      enable3d(() => new Phaser.Game(config)).withPhysics('lib/ammo/kripken')
    </script>
  </body>
</html>
