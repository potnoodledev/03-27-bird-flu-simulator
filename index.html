<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>First Person Shooter</title>
    <link rel="stylesheet" href="css/examples.css?ver=1.0.0" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script src="lib/phaser.min.js?ver=3.52.0"></script>
    <script src="lib/enable3d/enable3d.phaserExtension.0.25.4.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        touch-action: none;
        width: 100vw;
        height: 100vh;
        background-color: #000;
      }
      canvas {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
        display: block;
      }
      #info-text {
        position: fixed;
        top: 10px;
        width: 100%;
        text-align: center;
        color: white;
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        z-index: 100;
        padding: 0 15px;
        box-sizing: border-box;
      }
      @media (max-width: 768px) {
        #info-text {
          font-size: 12px;
          top: 5px;
        }
      }
      #mobile-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 200px;
        z-index: 10;
        pointer-events: none;
        display: none;
      }
      #joystick-area {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        background-color: rgba(255,255,255,0.2);
        border-radius: 60px;
        pointer-events: auto;
      }
      #joystick {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: rgba(255,255,255,0.5);
        border-radius: 30px;
        top: 30px;
        left: 30px;
      }
      #shoot-btn {
        position: absolute;
        bottom: 60px;
        right: 30px;
        width: 80px;
        height: 80px;
        background-color: rgba(255,0,0,0.3);
        border-radius: 40px;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
      }
      #aim-btn {
        position: absolute;
        bottom: 60px;
        right: 130px;
        width: 80px;
        height: 80px;
        background-color: rgba(0,0,255,0.3);
        border-radius: 40px;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Orbitron', sans-serif;
        color: white;
      }
      #debug-panel {
        position: fixed;
        top: 50px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: lime;
        font-family: monospace;
        font-size: 14px;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        width: 250px;
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <div id="info-text">
      <span class="desktop-controls">Use WASD to move, Q and E to tilt, right mouse button to aim and left mouse button to shoot.</span>
      <span class="mobile-controls">Use joystick to move, swipe to look around, tap right button to aim, and left button to shoot.</span>
      <span>Hunt down the 50 chickens!</span>
    </div>
    
    <div id="mobile-controls">
      <div id="joystick-area">
        <div id="joystick"></div>
      </div>
      <div id="shoot-btn">FIRE</div>
      <div id="aim-btn">AIM</div>
    </div>
    
    <div id="debug-panel">
      <div>DEBUG INFO:</div>
      <div id="joystick-status">Joystick: x=0, y=0</div>
      <div id="player-position">Position: x=0, y=0, z=0</div>
      <div id="movement-info">Movement: NONE</div>
    </div>

    <script>
      const { enable3d, Scene3D, Canvas, ThirdDimension, ExtendedObject3D, FirstPersonControls, THREE } = ENABLE3D

      // Debug panel elements
      const debugPanel = document.getElementById('debug-panel');
      const joystickStatus = document.getElementById('joystick-status');
      const playerPosition = document.getElementById('player-position');
      const movementInfo = document.getElementById('movement-info');

      class MainScene extends Scene3D {
        constructor() {
          super({ key: 'MainScene' })
          this.move = { x: 0, y: 0, z: 0 }
          this.chickens = []
          this.chickenModel = null
          this.chickenCount = 50
          this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
          this.joystickMovement = { x: 0, y: 0 }
          this.isAiming = false
          this.touchLook = { x: 0, y: 0 }
          this.lastTime = 0
          this.frameCount = 0
          this.debugMode = false // Debug mode off by default
        }

        postRender() {
          // Update minimap viewport positioning based on current screen dimensions
          const minimapSize = Math.min(window.innerWidth, window.innerHeight) * 0.15;
          const minimapX = Math.max(10, window.innerWidth * 0.05);
          const minimapY = Math.max(10, window.innerHeight * 0.05);
          
          this.third.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight)
          this.third.renderer.render(this.third.scene, this.third.camera)

          this.third.renderer.clearDepth()

          this.third.renderer.setScissorTest(true)
          this.third.renderer.setScissor(minimapX, minimapY, minimapSize, minimapSize * 0.75)
          this.third.renderer.setViewport(minimapX, minimapY, minimapSize, minimapSize * 0.75)

          this.third.renderer.render(this.third.scene, this.secondCamera)

          this.third.renderer.setScissorTest(false)
        }

        create() {
          this.accessThirdDimension({ maxSubSteps: 10, fixedTimeStep: 1 / 180 })

          this.third.warpSpeed('-orbitControls')
          this.third.renderer.gammaFactor = 1.5
          this.third.camera.layers.enable(1) // enable layer 1
          
          // Set renderer to match window size
          this.third.renderer.setSize(window.innerWidth, window.innerHeight)

          // Set up device-specific UI
          this.setupDeviceSpecificUI()

          // second camera
          this.secondCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)
          this.third.add.existing(this.secondCamera)
          this.third.camera.add(this.secondCamera)
          this.secondCamera.position.set(0, 15, 0) // Set position above player
          this.secondCamera.lookAt(0, 0, 0) // Look down at scene
          // this.secondCamera.layers.set(1)

          this.scene.scene.game.events.on('postrender', (renderer, time, delta) => {
            this.postRender()
          })

          this.third.load.gltf('assets/glb/chicken.glb').then(object => {
            const rifle = object.scene

            this.rifle = new ExtendedObject3D()
            this.rifle.name = 'rifle'
            this.rifle.add(rifle)

            this.third.add.existing(this.rifle)

            this.rifle.traverse(child => {
              if (child.isMesh) {
                child.layers.set(1) // mesh is in layer 1
                child.castShadow = child.receiveShadow = true
                if (child.material) child.material.metalness = 0
              }
            })
            
            // Now that the model is loaded, use it to create chickens
            this.createChickens(object)
          })

          // add red dot
          this.redDot = this.add.circle(this.cameras.main.width / 2, this.cameras.main.height / 2, 4, 0xff0000)
          this.redDot.depth = 1

          // add player
          this.player = new ExtendedObject3D()
          this.player.position.setY(2)
          
          // create an array to store bullets
          this.bullets = []

          // add first person controls with explicit update option
          this.firstPersonControls = new FirstPersonControls(this.third.camera, this.player, {
            pointerLock: !this.isMobile,
            enableZoom: false
          });

          // Setup controls based on device
          if (!this.isMobile) {
            // Desktop controls
            // lock the pointer and update the first person control
            this.input.on('pointerdown', () => {
              this.input.mouse.requestPointerLock()
            })
            this.input.on('pointermove', pointer => {
              if (this.input.mouse.locked) {
                this.firstPersonControls.update(pointer.movementX, pointer.movementY)
              }
            })
            this.events.on('update', () => {
              this.firstPersonControls.update(0, 0)
            })
          } else {
            // Mobile Touch controls setup
            this.setupMobileTouchControls()
          }

          // add keys
          this.keys = {
            w: this.input.keyboard.addKey('w'),
            a: this.input.keyboard.addKey('a'),
            s: this.input.keyboard.addKey('s'),
            d: this.input.keyboard.addKey('d'),
            q: this.input.keyboard.addKey('q'),
            e: this.input.keyboard.addKey('e')
          }

          // Mark ground as non-destructible
          this.third.physics.add.ground({ width: 50, height: 50, name: 'ground', userData: { destructible: false } })
          
          // Add UI for remaining chickens
          this.chickensRemainingText = this.add.text(10, 10, `Chickens: ${this.chickenCount}`, { 
            fontSize: this.isMobile ? '18px' : '24px', 
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 4,
            fontFamily: 'Orbitron'
          })
          this.chickensRemainingText.setScrollFactor(0)
          this.chickensRemainingText.depth = 1000

          // Make game respond to window resizing
          window.addEventListener('resize', () => this.handleResize());
        }
        
        setupDeviceSpecificUI() {
          // Show/hide appropriate controls based on device
          const mobileControls = document.getElementById('mobile-controls');
          const desktopControlsInfo = document.querySelector('.desktop-controls');
          const mobileControlsInfo = document.querySelector('.mobile-controls');
          
          if (this.isMobile) {
            mobileControls.style.display = 'block';
            desktopControlsInfo.style.display = 'none';
            mobileControlsInfo.style.display = 'inline';
          } else {
            mobileControls.style.display = 'none';
            desktopControlsInfo.style.display = 'inline';
            mobileControlsInfo.style.display = 'none';
          }
          
          // Set debug panel visibility based on debug mode
          debugPanel.style.display = this.debugMode ? 'block' : 'none';
          
          // Add debug toggle key (D key)
          this.input.keyboard.on('keydown-D', () => {
            this.debugMode = !this.debugMode;
            debugPanel.style.display = this.debugMode ? 'block' : 'none';
          });
          
          // Add touch-based debug toggle (triple tap top-right corner)
          let tapCount = 0;
          let lastTapTime = 0;
          
          document.addEventListener('touchend', (event) => {
            const touch = event.changedTouches[0];
            const now = new Date().getTime();
            const corner = touch.clientX > window.innerWidth * 0.8 && touch.clientY < window.innerHeight * 0.2;
            
            if (corner) {
              if (now - lastTapTime < 500) { // Within 500ms
                tapCount++;
                if (tapCount >= 3) { // Triple tap
                  this.debugMode = !this.debugMode;
                  debugPanel.style.display = this.debugMode ? 'block' : 'none';
                  tapCount = 0;
                }
              } else {
                tapCount = 1;
              }
              lastTapTime = now;
            }
          });
        }

        setupMobileTouchControls() {
          // Get DOM elements
          const joystickArea = document.getElementById('joystick-area');
          const joystick = document.getElementById('joystick');
          const shootBtn = document.getElementById('shoot-btn');
          const aimBtn = document.getElementById('aim-btn');
          
          // Initialize joystick in center position
          const centerJoystick = () => {
            joystick.style.left = (joystickArea.offsetWidth / 2 - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (joystickArea.offsetHeight / 2 - joystick.offsetHeight / 2) + 'px';
          };
          centerJoystick();
          
          // Joystick controls
          let joystickActive = false;
          
          // Touch start for joystick
          joystickArea.addEventListener('touchstart', (event) => {
            event.preventDefault();
            joystickActive = true;
            updateJoystickPosition(event.touches[0]);
          });
          
          // Touch move for joystick
          joystickArea.addEventListener('touchmove', (event) => {
            if (joystickActive) {
              event.preventDefault();
              updateJoystickPosition(event.touches[0]);
            }
          });
          
          // Function to update joystick position
          const updateJoystickPosition = (touch) => {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Calculate distance from center
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            // Limit to joystick area radius
            const maxRadius = rect.width / 2 - joystick.offsetWidth / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > maxRadius) {
              dx = (dx / distance) * maxRadius;
              dy = (dy / distance) * maxRadius;
            }
            
            // Update joystick visual position
            joystick.style.left = (rect.width / 2 - joystick.offsetWidth / 2 + dx) + 'px';
            joystick.style.top = (rect.height / 2 - joystick.offsetHeight / 2 + dy) + 'px';
            
            // Update movement values (-1 to 1)
            this.joystickMovement.x = dx / maxRadius;
            this.joystickMovement.y = dy / maxRadius;
            
            // Update debug display
            joystickStatus.textContent = `Joystick: x=${this.joystickMovement.x.toFixed(2)}, y=${this.joystickMovement.y.toFixed(2)}`;
            
            // Determine movement direction based on joystick position
            let directionText = "Movement: ";
            if (Math.abs(this.joystickMovement.y) > 0.2) {
                directionText += this.joystickMovement.y < 0 ? "FORWARD" : "BACKWARD";
            }
            if (Math.abs(this.joystickMovement.x) > 0.2) {
                directionText += this.joystickMovement.x < 0 ? " LEFT" : " RIGHT";
            }
            if (Math.abs(this.joystickMovement.y) <= 0.2 && Math.abs(this.joystickMovement.x) <= 0.2) {
                directionText += "NONE";
            }
            movementInfo.textContent = directionText;
          };
          
          // Touch end for joystick
          joystickArea.addEventListener('touchend', (event) => {
            event.preventDefault();
            joystickActive = false;
            centerJoystick();
            this.joystickMovement.x = 0;
            this.joystickMovement.y = 0;
            joystickStatus.textContent = "Joystick: x=0.00, y=0.00";
            movementInfo.textContent = "Movement: NONE";
          });
          
          joystickArea.addEventListener('touchcancel', (event) => {
            event.preventDefault();
            joystickActive = false;
            centerJoystick();
            this.joystickMovement.x = 0;
            this.joystickMovement.y = 0;
            joystickStatus.textContent = "Joystick: x=0.00, y=0.00";
            movementInfo.textContent = "Movement: NONE";
          });
          
          // Shooting button
          shootBtn.addEventListener('touchstart', (event) => {
            event.preventDefault();
            this.shoot();
          });
          
          // Aiming button
          aimBtn.addEventListener('touchstart', (event) => {
            event.preventDefault();
            this.isAiming = true;
          });
          
          aimBtn.addEventListener('touchend', (event) => {
            event.preventDefault();
            this.isAiming = false;
          });
          
          // Touch look controls (for camera rotation)
          let lastX = 0;
          let lastY = 0;
          let lookActive = false;
          
          // Make the entire right side of screen rotate camera
          document.addEventListener('touchstart', (event) => {
            const touch = event.touches[0];
            if (touch.clientX > window.innerWidth / 2) {
              lookActive = true;
              lastX = touch.clientX;
              lastY = touch.clientY;
              event.preventDefault();
            }
          }, { passive: false });
          
          document.addEventListener('touchmove', (event) => {
            if (lookActive) {
              const touch = event.touches[0];
              
              // Calculate movement deltas
              const dx = touch.clientX - lastX;
              const dy = touch.clientY - lastY;
              
              // Update camera based on touch movement
              this.firstPersonControls.update(dx * 1.5, dy * 1.5);
              
              // Store last position
              lastX = touch.clientX;
              lastY = touch.clientY;
              
              event.preventDefault();
            }
          }, { passive: false });
          
          document.addEventListener('touchend', (event) => {
            if (lookActive) {
              lookActive = false;
              event.preventDefault();
            }
          }, { passive: false });
        }
        
        shoot() {
          const x = 0;
          const y = 0;
          const force = 5;
          const pos = new THREE.Vector3();
          const raycaster = new THREE.Raycaster();

          raycaster.setFromCamera({ x, y }, this.third.camera);

          pos.copy(raycaster.ray.direction);
          pos.add(raycaster.ray.origin);

          const sphere = this.third.physics.add.sphere(
            { radius: 0.05, x: pos.x, y: pos.y, z: pos.z, mass: 5, bufferGeometry: true },
            { phong: { color: 0x33ee22 } }
          );

          pos.copy(raycaster.ray.direction);
          pos.multiplyScalar(24);

          sphere.body.applyForce(pos.x * force, pos.y * force, pos.z * force);
          
          // Track the bullet
          this.bullets.push(sphere);
          
          // Add collision detection to the bullet
          sphere.body.on.collision((otherObject, event) => {
            if (otherObject.name !== 'ground' && otherObject.name !== 'rifle') {
              // Destroy the hit object
              if (otherObject.userData.destructible !== false) {
                // Check if it's a chicken
                if (otherObject.name.includes('chicken')) {
                  // Mark as destroyed for counting purposes
                  otherObject.body.isDestroyed = true;
                  
                  // Play death animation - fade out and sink into ground
                  const deathAnimation = this.tweens.add({
                    targets: [otherObject.position],
                    y: -1,
                    duration: 1000,
                    ease: 'Power2',
                    onComplete: () => {
                      // Only remove when animation is complete
                      this.third.scene.remove(otherObject);
                      this.third.physics.destroy(otherObject);
                    }
                  });
                } else {
                  // Non-chicken objects
                  this.third.scene.remove(otherObject);
                  this.third.physics.destroy(otherObject);
                }
              }
              
              // Destroy the bullet
              this.third.scene.remove(sphere);
              this.third.physics.destroy(sphere);
              
              // Remove bullet from the array
              const index = this.bullets.indexOf(sphere);
              if (index > -1) {
                this.bullets.splice(index, 1);
              }
            }
          });
        }
        
        handleResize() {
          // Get actual window dimensions
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          // Update camera aspect ratio
          this.third.camera.aspect = width / height;
          this.third.camera.updateProjectionMatrix();
          
          // Update second camera
          if (this.secondCamera) {
            this.secondCamera.aspect = width / height;
            this.secondCamera.updateProjectionMatrix();
          }
          
          // Update renderer and make sure it takes full screen
          this.third.renderer.setSize(width, height);
          
          // Update scene size
          this.scale.resize(width, height);
          
          // Update UI positions
          if (this.chickensRemainingText) {
            this.chickensRemainingText.setPosition(10, 10);
          }
          
          // Update red dot position
          if (this.redDot) {
            this.redDot.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);
          }
        }
        
        createChickens(model) {
          // Create 50 chickens scattered around the map
          for (let i = 0; i < this.chickenCount; i++) {
            // Clone the chicken model
            const chickenScene = model.scene.clone()
            
            // Create a new ExtendedObject3D for the chicken
            const chicken = new ExtendedObject3D()
            chicken.name = `chicken_${i}`
            chicken.add(chickenScene)
            
            // Set random position within a reasonable area
            const x = (Math.random() - 0.5) * 40
            const z = (Math.random() - 0.5) * 40
            chicken.position.set(x, 10, z)
            
            // Random rotation
            chicken.rotation.y = Math.random() * Math.PI * 2
            
            // Scale down the chicken
            chicken.scale.set(0.5, 0.5, 0.5)
            
            // Set chicken properties
            chicken.userData.destructible = true
            
            // Add to scene
            this.third.add.existing(chicken)
            
            // Add physics body to chicken
            chicken.physics = this.third.physics.add.existing(chicken, {
              shape: 'box',
              width: 0.5,
              height: 1.4,
              depth: 0.5,
              mass: 1
            })
            
            // Tweak physics body
            chicken.body.setFriction(0.8)
            chicken.body.setAngularFactor(0, 1, 0) // Only allow rotation around Y axis
            
            // Store in array for easy access
            this.chickens.push(chicken)
          }
        }

        update(time, delta) {
          // Calculate actual delta for smoother movement
          const dt = this.lastTime ? (time - this.lastTime) / 1000 : 0.016;
          this.lastTime = time;
          
          // Update player position debug info only in debug mode
          this.frameCount++;
          if (this.debugMode && this.frameCount % (this.isMobile ? 2 : 10) === 0 && this.player) {
            playerPosition.textContent = `Position: x=${this.player.position.x.toFixed(2)}, y=${this.player.position.y.toFixed(2)}, z=${this.player.position.z.toFixed(2)}`;
          }
          
          if (this.rifle && this.player) {
            // Update chicken counter
            if (this.chickensRemainingText) {
              const remainingChickens = this.chickens.filter(chicken => chicken.body && !chicken.body.isDestroyed).length
              this.chickensRemainingText.setText(`Chickens: ${remainingChickens}`)
            }
            
            // some variables
            const zoom = this.isMobile ? this.isAiming : this.input.mousePointer.rightButtonDown()
            const speed = 0.1 * (60 * dt); // Time-based movement for consistent speed
            const direction = new THREE.Vector3()
            const rotation = this.third.camera.getWorldDirection(direction)
            const theta = Math.atan2(rotation.x, rotation.z)

            // reset red dot
            this.redDot.alpha = 1

            // the rifle movement
            if (zoom) {
              this.redDot.alpha = 0
              this.move.x = THREE.MathUtils.lerp(this.move.x, 0.6, 0.2)
              this.move.y = THREE.MathUtils.lerp(this.move.y, -0.8 + 1.8, 0.2)
              this.move.z = THREE.MathUtils.lerp(this.move.z, -0.45, 0.2)
            } else if ((this.isMobile && Math.abs(this.joystickMovement.y) > 0.1) || 
                      (!this.isMobile && this.keys.w.isDown)) {
              this.move.x = Math.sin(time * -0.015) * 0.075
              this.move.y = Math.sin(time * 0.015) * 0.075
              this.move.z = Math.sin(time * 0.015) * 0.075
            } else {
              this.move.x = Math.sin(time * -0.003) * 0.01
              this.move.y = Math.sin(time * 0.003) * 0.01
              this.move.z = Math.sin(time * 0.003) * 0.01
            }

            // tilt
            if (this.keys.q.isDown) {
              this.third.camera.rotateZ(0.2)
              this.firstPersonControls.offset = new THREE.Vector3(
                Math.sin(theta + Math.PI * 0.5) * 0.4,
                0,
                Math.cos(theta + Math.PI * 0.5) * 0.4
              )
            } else if (this.keys.e.isDown) {
              this.third.camera.rotateZ(-0.2)
              this.firstPersonControls.offset = new THREE.Vector3(
                Math.sin(theta - Math.PI * 0.5) * 0.4,
                0,
                Math.cos(theta - Math.PI * 0.5) * 0.4
              )
            } else {
              this.third.camera.rotateZ(0)
              this.firstPersonControls.offset = new THREE.Vector3(0, 0, 0)
            }

            // adjust the position of the rifle to the camera
            const raycaster = new THREE.Raycaster()
            // x and y are normalized device coordinates from -1 to +1
            raycaster.setFromCamera({ 
              x: -1 - this.move.x, 
              y: -1.5 - this.move.y,
            }, this.third.camera)
            const pos = new THREE.Vector3()
            pos.copy(raycaster.ray.direction)
            pos.multiplyScalar(1.6 + this.move.z)
            pos.add(raycaster.ray.origin)

            this.rifle.position.copy(pos)
            this.rifle.rotation.copy(this.third.camera.rotation)

            // Flag to track if player moved this frame
            let playerMoved = false;
            let moveVector = new THREE.Vector3(0, 0, 0);

            // Handle movement based on device type
            if (this.isMobile) {
              // Enhanced mobile joystick movement
              // Apply a deadzone to prevent drift
              const deadzone = 0.15;
              const joystickX = Math.abs(this.joystickMovement.x) > deadzone ? this.joystickMovement.x : 0;
              const joystickY = Math.abs(this.joystickMovement.y) > deadzone ? this.joystickMovement.y : 0;
              
              // Forward/backward movement (inverted Y axis from joystick)
              if (joystickY !== 0) {
                // Invert Y axis (up is negative in the joystick, but should move forward)
                const moveSpeed = speed * 2.0 * -joystickY; // Increased speed even more
                moveVector.x += Math.sin(theta) * moveSpeed;
                moveVector.z += Math.cos(theta) * moveSpeed;
                playerMoved = true;
                
                // Debug - track actual movement when joystick is moved
                if (this.debugMode && this.frameCount % 5 === 0) {
                  console.log(`Moving: ${moveSpeed.toFixed(2)} at angle ${theta.toFixed(2)}`);
                }
              }
              
              // Strafe left/right movement - fix inversion
              if (joystickX !== 0) {
                // Invert X to fix controls (negative = right, positive = left)
                const strafeSpeed = speed * 2.0 * -joystickX; // Invert joystickX to fix direction
                moveVector.x += Math.sin(theta + Math.PI * 0.5) * strafeSpeed;
                moveVector.z += Math.cos(theta + Math.PI * 0.5) * strafeSpeed;
                playerMoved = true;
                
                // Debug - track actual movement when joystick is moved
                if (this.debugMode && this.frameCount % 5 === 0) {
                  console.log(`Strafing: ${strafeSpeed.toFixed(2)}`);
                }
              }
              
              // Apply movement vector to player position
              if (playerMoved) {
                this.player.position.x += moveVector.x;
                this.player.position.z += moveVector.z;
                
                // Force camera to update with player position
                this.firstPersonControls.update(0, 0, true);
              }
            } else {
              // Desktop keyboard movement - keep original logic
              // move forwards and backwards
              if (this.keys.w.isDown) {
                this.player.position.x += Math.sin(theta) * speed;
                this.player.position.z += Math.cos(theta) * speed;
                playerMoved = true;
              } else if (this.keys.s.isDown) {
                this.player.position.x -= Math.sin(theta) * speed;
                this.player.position.z -= Math.cos(theta) * speed;
                playerMoved = true;
              }

              // move sideways
              if (this.keys.a.isDown) {
                this.player.position.x += Math.sin(theta + Math.PI * 0.5) * speed;
                this.player.position.z += Math.cos(theta + Math.PI * 0.5) * speed;
                playerMoved = true;
              } else if (this.keys.d.isDown) {
                this.player.position.x += Math.sin(theta - Math.PI * 0.5) * speed;
                this.player.position.z += Math.cos(theta - Math.PI * 0.5) * speed;
                playerMoved = true;
              }
              
              // Force camera to update if player moved
              if (playerMoved) {
                this.firstPersonControls.update(0, 0, true);
              }

              // shoot
              if (this.input.mousePointer.leftButtonDown()) {
                this.shoot();
              }
            }
            
            // Make chickens move more slowly
            if (this.chickens.length > 0 && Math.random() < 0.01) {
              // Randomly select a chicken that isn't destroyed
              const liveChickens = this.chickens.filter(chicken => chicken.body && !chicken.body.isDestroyed)
              if (liveChickens.length > 0) {
                const randomChicken = liveChickens[Math.floor(Math.random() * liveChickens.length)]
                
                // Apply smaller random movement force (reduced by 75%)
                const forceX = (Math.random() - 0.5) * 0.5; // Reduced from 2.0 to 0.5
                const forceZ = (Math.random() - 0.5) * 0.5;
                
                randomChicken.body.applyForce(forceX, 0, forceZ)
                
                // Also rotate to face movement direction
                if (forceX !== 0 || forceZ !== 0) {
                  const angle = Math.atan2(forceX, forceZ)
                  randomChicken.rotation.y = angle
                }
              }
            }
          }
        }
      }

      const config = {
        type: Phaser.WEBGL,
        transparent: true,
        scale: {
          mode: Phaser.Scale.RESIZE,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: window.innerWidth,
          height: window.innerHeight,
          parent: document.body
        },
        backgroundColor: '#000000',
        scene: [MainScene],
        ...Canvas({ antialias: true })
      }

      window.addEventListener('load', () => {
        // Force a resize before game starts to ensure canvas is properly sized
        window.dispatchEvent(new Event('resize'));
        
        // Initialize the game with physics
        enable3d(() => new Phaser.Game(config)).withPhysics('lib/ammo/kripken');
      });
    </script>
  </body>
</html>
